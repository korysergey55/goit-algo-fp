## Завдання 1 - висновки:

1. **Реверсування списку:**

   - Функція `reverse_linked_list` змінює посилання між вузлами списку таким чином, що останній вузол стає першим, передостанній — другим і так далі.
   - Реалізація функції реверсування є правильною, посилання між вузлами змінюються коректно.

2. **Сортування вставками:**

   - Алгоритм сортування вставками поступово бере елементи з початкового списку і вставляє їх у правильному порядку в новий відсортований список.
   - Алгоритм сортування вставками працює коректно для однозв'язних списків, впорядковуючи елементи у зростаючому порядку.

3. **Об'єднання двох відсортованих списків:**

   - Функція `merge_sorted_lists` об'єднує два відсортовані списки, створюючи новий відсортований список шляхом порівняння та злиття елементів обох списків.
   - Функція злиття двох відсортованих списків коректно об'єднує їх в один відсортований список.


## Завдання 2 - висновки:

1. **Правильність реалізації:**

   - Програма коректно реалізує рекурсивний алгоритм для малювання `дерева Піфагора`.
   - Використання `math.cos(math.radians(angle))` для скорочення довжини гілок забезпечує стабільне скорочення і запобігає накопиченню помилок.

2. **Гнучкість:**

   - Користувач має можливість вказати рівень рекурсії, що дозволяє контролювати деталізацію та складність фрактала.

3. **Візуалізація:**

   - Програма успішно візуалізує фрактал `"дерево Піфагора"` з будь-яким рівнем рекурсії, забезпечуючи наочність та чіткість малюнка.


## Завдання 3 - висновки:

1. **Правильність реалізації:**

   - Алгоритм Дейкстри коректно реалізований з використанням бінарної купи `(heapq)`.
   - Відстані обчислюються правильно, і алгоритм ефективно знаходить найкоротші шляхи у зваженому графі.

2. **Гнучкість:**

   - Граф можна легко змінити, додавши або видаливши вершини і ребра.

3. **Ефективність:**

   - Використання бінарної купи оптимізує вибір вершин, зменшуючи час виконання алгоритму порівняно з наївною реалізацією.


## Завдання 4 - висновки:

1. **Візуалізація бінарної купи**:

   - Функція для візуалізації бінарної купи успішно реалізована.
   - Відображення дерева показує коректну структуру бінарної купи.

2. **Коректність виконання програми**:
   - Програма правильно відображає вузли та їхні зв'язки, використовуючи бібліотеку `networkx`.
   - Всі тестові приклади демонструють правильність роботи функції візуалізації.



## Завдання 5 - висновки:

1. **Алгоритми DFS та BFS:**

   - Реалізовані алгоритми обходу в глибину `(DFS)` та в ширину `(BFS)` коректно працюють, використовуючи стек та чергу відповідно.

2. **Кольорове відображення порядку обходу:**

   - Вузли дерева забарвлюються у відтінки від темних до світлих, залежно від порядку обходу, що робить процес обходу більш наочним.

3. **Візуалізація процесу обходу:**

   - Кожен крок обходу дерева відображається на графіку, що дозволяє відстежувати послідовність відвідування вузлів та забезпечує наочність алгоритмів.



## Завдання 6 - висновки:

1. **Жадібний алгоритм:**

   - Функція `greedy_algorithm()` вибирає страви з максимальним співвідношенням калорій до вартості в межах бюджету.
   - Обчислює співвідношення калорій до вартості для кожної страви.
   - Сортує страви за цим співвідношенням і вибирає страви, поки дозволяє бюджет.
   - Жадібний алгоритм ефективно вибирає страви для максимізації співвідношення калорій до вартості.

2. **Динамічне програмування:**

   - Функція `dynamic_programming()` обчислює оптимальний набір страв для максимізації калорійності при заданому бюджеті.
   - Створює таблицю для зберігання максимальної калорійності для кожного можливого бюджету.
   - Для кожної страви оновлює таблицю на основі поточного бюджету.
   - Визначає оптимальний набір страв для максимізації калорійності при заданому бюджеті.
   - Динамічне програмування дає оптимальне рішення для максимізації калорійності при заданому бюджеті.


## Завдання 7 - висновки:

### Порівняння ймовірностей кидання двох кубиків

У цій таблиці представлені ймовірності для кожної суми, отримані за допомогою методу Монте-Карло, а також аналітичні розрахунки ймовірностей. Вказано також відхилення між обчисленими ймовірностями.

| Сума | Ймовірність (Метод Монте-Карло) | Ймовірність (Аналітична) | Відхилення (%) |
| ---- | ------------------------------- | ------------------------ | -------------- |
| 2    | 2.83%                           | 2.78%                    | +0.05%         |
| 3    | 5.39%                           | 5.56%                    | -0.17%         |
| 4    | 8.38%                           | 8.33%                    | +0.05%         |
| 5    | 11.18%                          | 11.11%                   | +0.07%         |
| 6    | 13.84%                          | 13.89%                   | -0.05%         |
| 7    | 16.59%                          | 16.67%                   | -0.08%         |
| 8    | 13.96%                          | 13.89%                   | +0.07%         |
| 9    | 11.25%                          | 11.11%                   | +0.14%         |
| 10   | 8.34%                           | 8.33%                    | +0.01%         |
| 11   | 5.54%                           | 5.56%                    | -0.02%         |
| 12   | 2.69%                           | 2.78%                    | -0.09%         |

### Аналіз Результатів

1. **Точність Монте-Карло**:

   - Відхилення між ймовірностями, отриманими за допомогою методу Монте-Карло, та аналітичними розрахунками є незначним. Відхилення варіюється від -0.17% до +0.14%, що свідчить про точність методу Монте-Карло при великій кількості симуляцій.

2. **Відповідність**:

   - Результати методу Монте-Карло в основному відповідають аналітичним розрахункам, з незначними відхиленнями. Це підтверджує правильність симуляцій і те, що використані симуляції були достатньо великі, щоб наблизитися до аналітичних результатів.

3. **Природа Відхилень**:
   - Незначні відхилення можуть бути зумовлені випадковим характером симуляцій, і вони є нормальною частиною використання методу Монте-Карло. Більше симуляцій могли б зменшити ці відхилення, проте з практичної точки зору результати вже досить близькі до аналітичних значень.

### Висновок

Отримані результати за допомогою методу Монте-Карло дуже близькі до аналітичних значень, що підтверджує ефективність і точність симуляцій при достатньо великій кількості ітерацій. Це демонструє, що метод Монте-Карло може бути надійним інструментом для оцінки ймовірностей у випадкових процесах, таких як кидання кубиків.

